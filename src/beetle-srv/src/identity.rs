/// The uuid crate's `new_v4()` method will build us random-enough of string that is a bit
/// too long to be easily consumed from the display. Here we're shrinking it down to 10
/// characters which should theoretically still have 16^16 possibilities.
///
/// It is important that there are 16 characters in here, so we can represent a 128 bit key
/// (16 * 8 = 128) for aes encryption. We're missing out on a _huge_ amount of possible
/// values by limiting ourselves to the characters generated by uuids (hex char values -
/// 0-9 + a-f).
fn shorten(input: String) -> String {
  let shorter = input.chars().filter(|c| *c != '-').take(16).collect::<String>();
  let (f, b) = shorter.split_at(8);
  format!("{}-{}", f, b)
}

pub fn create() -> String {
  shorten(uuid::Uuid::new_v4().to_string())
}

#[cfg(test)]
mod test {
  use super::shorten;

  #[test]
  fn test_is_short() {
    let out = shorten(uuid::Uuid::new_v4().to_string());
    println!("{out}");
    assert_eq!(out.len(), 17);
  }
}
